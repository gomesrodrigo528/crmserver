#!/usr/bin/env node
/**
 * Servidor Node.js Multi-Tenant com Baileys para integra√ß√£o WhatsApp
 * Gerencia m√∫ltiplas conex√µes WhatsApp simultaneamente
 */

import makeWASocket, {
    useMultiFileAuthState,
    DisconnectReason,
    fetchLatestBaileysVersion
} from "@whiskeysockets/baileys";
import express from "express";
import axios from "axios";
import { Boom } from "@hapi/boom";
import qrcode from "qrcode-terminal";
import fs from "fs/promises";
import path from "path";
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
app.use(express.json());

// ========== CORS CONFIGURATION ========== //
app.use((req, res, next) => {
    // Permitir todas as origens para desenvolvimento
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');

    // Responder preflight requests
    if (req.method === 'OPTIONS') {
        res.sendStatus(200);
    } else {
        next();
    }
});

// Configura√ß√µes
const FLASK_URL = "https://suaagenda.fun";
const PORT = 3000;
const AUTH_DIR = path.join(__dirname, 'auth');

// Classe para gerenciar cada tenant WhatsApp
class WhatsAppTenant {
    constructor(tenantId) {
        this.tenantId = tenantId;
        this.sock = null;
        this.isConnected = false;
        this.qrCode = null;
        this.authDir = path.join(AUTH_DIR, tenantId);
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
    }

    async initialize() {
        try {
            // Cria diret√≥rio de autentica√ß√£o se n√£o existir
            await fs.mkdir(this.authDir, { recursive: true });

            // Usa estado de autentica√ß√£o persistente para este tenant
            const { state, saveCreds } = await useMultiFileAuthState(this.authDir);

            // Busca a vers√£o mais recente do Baileys
            const { version } = await fetchLatestBaileysVersion();

            // Cria o socket do WhatsApp para este tenant
            this.sock = makeWASocket({
                version,
                printQRInTerminal: false,
                auth: state,
                browser: [`WhatsApp-${this.tenantId}`, 'Chrome', '1.0.0'],
                // Configura√ß√µes para melhorar estabilidade
                generateHighQualityLinkPreview: false,
                syncFullHistory: false,
                markOnlineOnConnect: false,
                defaultQueryTimeoutMs: 30000
            });

            // Salva credenciais quando atualizadas
            this.sock.ev.on('creds.update', saveCreds);

            // Evento de conex√£o
            this.sock.ev.on('connection.update', (update) => {
                this.handleConnectionUpdate(update);
            });

            // Evento de mensagens recebidas
            this.sock.ev.on('messages.upsert', async (m) => {
                await this.handleMessage(m);
            });

            console.log(`‚úÖ Tenant ${this.tenantId} inicializado`);

        } catch (error) {
            console.error(`‚ùå Erro ao inicializar tenant ${this.tenantId}:`, error);
            throw error;
        }
    }

    handleConnectionUpdate(update) {
        const { connection, lastDisconnect, qr } = update;

        if (qr) {
            this.qrCode = qr;
            this.reconnectAttempts = 0; // Reset das tentativas quando QR √© gerado
            console.log(`üì± QR Code gerado para tenant ${this.tenantId}`);
            // Emite evento para API acessar o QR
            this.emit('qr', { tenantId: this.tenantId, qr: qr });
        }

        if (connection === 'close') {
            this.isConnected = false;
            this.qrCode = null;

            const shouldReconnect = (lastDisconnect?.error)?.output?.statusCode !== DisconnectReason.loggedOut;
            const errorCode = (lastDisconnect?.error)?.output?.statusCode;

            console.log(`‚ùå Tenant ${this.tenantId} desconectado:`, {
                error: lastDisconnect?.error?.message || 'Erro desconhecido',
                code: errorCode,
                shouldReconnect: shouldReconnect
            });

            // N√£o reconectar se foi logout pelo usu√°rio
            if (!shouldReconnect) {
                console.log(`üö™ Tenant ${this.tenantId} deslogado pelo usu√°rio`);
                return;
            }

            // Reconectar com delay progressivo (m√°x 30s)
            if (this.reconnectAttempts < this.maxReconnectAttempts) {
                this.reconnectAttempts++;
                const delay = Math.min(5000 * this.reconnectAttempts, 30000); // M√°x 30s
                console.log(`üîÑ Tentando reconectar tenant ${this.tenantId} em ${delay}ms (tentativa ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);

                setTimeout(async () => {
                    try {
                        await this.reconnect();
                    } catch (error) {
                        console.error(`‚ùå Erro na reconex√£o do tenant ${this.tenantId}:`, error);
                    }
                }, delay);
            } else {
                console.log(`‚ùå M√°ximo de tentativas de reconex√£o atingido para tenant ${this.tenantId}`);
            }

        } else if (connection === 'open') {
            console.log(`‚úÖ Tenant ${this.tenantId} conectado ao WhatsApp!`);
            this.isConnected = true;
            this.reconnectAttempts = 0;
            this.qrCode = null;
            this.emit('connected', { tenantId: this.tenantId });
        }
    }

    async handleMessage(m) {
        try {
            const message = m.messages[0];

            // Verifica√ß√µes de seguran√ßa
            if (!message) {
                console.log(`‚ö†Ô∏è Mensagem vazia recebida no tenant ${this.tenantId}`);
                return;
            }

            // Verifica se √© uma mensagem de texto
            if (!message.message?.conversation && !message.message?.extendedTextMessage?.text) {
                return; // N√£o √© texto, ignora
            }

            // Extrai o texto da mensagem
            const text = message.message.conversation || message.message.extendedTextMessage.text;

            // Extrai o n√∫mero do telefone
            const phone = message.key.remoteJid.replace("@s.whatsapp.net", "");

            // Ignora mensagens pr√≥prias
            if (message.key.fromMe) {
                return;
            }

            // Verifica se o telefone √© v√°lido
            if (!phone || phone.length < 10) {
                console.log(`‚ö†Ô∏è Telefone inv√°lido: ${phone}`);
                return;
            }

            console.log(`üì® [${this.tenantId}] Mensagem recebida de ${phone}: ${text.substring(0, 100)}${text.length > 100 ? '...' : ''}`);

            // Envia diretamente para o Flask via webhook
            try {
                const response = await axios.post(`${FLASK_URL}/webhook/whatsapp`, {
                    phone: phone,
                    message: text,
                    message_type: 'texto',
                    empresa_id: this.tenantId
                }, {
                    timeout: 10000 // 10 segundos timeout
                });

                if (response.status === 200) {
                    console.log(`‚úÖ [${this.tenantId}] Webhook enviado para Flask: ${phone}`);
                } else {
                    console.error(`‚ùå [${this.tenantId}] Flask retornou status ${response.status}`);
                }
            } catch (error) {
                if (error.code === 'ECONNREFUSED') {
                    console.error(`‚ùå [${this.tenantId}] Flask n√£o est√° rodando em ${FLASK_URL}`);
                } else {
                    console.error(`‚ùå [${this.tenantId}] Erro ao enviar webhook para Flask: ${error.message}`);
                }
            }

        } catch (error) {
            console.error(`‚ùå [${this.tenantId}] Erro ao processar mensagem:`, error.message);
        }
    }

    async connect() {
        try {
            // Se j√° est√° conectado, n√£o faz nada
            if (this.isConnected && this.sock) {
                console.log(`‚úÖ Tenant ${this.tenantId} j√° est√° conectado`);
                return;
            }

            // Se tem socket mas n√£o est√° conectado, desconecta primeiro
            if (this.sock) {
                console.log(`üîÑ Reinicializando conex√£o do tenant ${this.tenantId}`);
                await this.disconnect();
                // Pequena pausa antes de reconectar
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            await this.initialize();
        } catch (error) {
            console.error(`‚ùå Erro ao conectar tenant ${this.tenantId}:`, error);
            throw error;
        }
    }

    async reconnect() {
        console.log(`üîÑ Reconectando tenant ${this.tenantId}...`);
        await this.connect();
    }

    async disconnect() {
        if (this.sock) {
            await this.sock.logout();
            this.sock = null;
            this.isConnected = false;
            this.qrCode = null;
        }
    }

    async sendMessage(phone, message) {
        if (!this.isConnected || !this.sock) {
            throw new Error('Tenant n√£o est√° conectado');
        }

        // Formata o n√∫mero do telefone
        const formattedPhone = phone.includes('@') ? phone : `${phone}@s.whatsapp.net`;

        // Envia a mensagem
        await this.sock.sendMessage(formattedPhone, { text: message });

        console.log(`‚úÖ [${this.tenantId}] Mensagem enviada para ${phone}: ${message}`);
        return { success: true, message: 'Mensagem enviada com sucesso' };
    }

    getStatus() {
        return {
            tenantId: this.tenantId,
            connected: this.isConnected,
            qrCode: this.qrCode ? true : false,
            reconnectAttempts: this.reconnectAttempts
        };
    }
}

// Gerenciador de tenants
class TenantManager {
    constructor() {
        this.tenants = new Map();
        this.events = new Map();
    }

    async createTenant(tenantId) {
        if (this.tenants.has(tenantId)) {
            throw new Error(`Tenant ${tenantId} j√° existe`);
        }

        const tenant = new WhatsAppTenant(tenantId);
        this.tenants.set(tenantId, tenant);

        // Configura listeners de eventos
        tenant.on = (event, callback) => {
            if (!this.events.has(event)) {
                this.events.set(event, new Map());
            }
            this.events.get(event).set(tenantId, callback);
        };

        tenant.emit = (event, data) => {
            if (this.events.has(event)) {
                const callbacks = this.events.get(event);
                if (callbacks.has(tenantId)) {
                    callbacks.get(tenantId)(data);
                }
            }
        };

        await tenant.initialize();
        return tenant;
    }

    async getTenant(tenantId) {
        if (!this.tenants.has(tenantId)) {
            await this.createTenant(tenantId);
        }
        return this.tenants.get(tenantId);
    }

    async deleteTenant(tenantId) {
        const tenant = this.tenants.get(tenantId);
        if (tenant) {
            await tenant.disconnect();
            this.tenants.delete(tenantId);
            // Remove eventos
            this.events.forEach(eventMap => eventMap.delete(tenantId));
            // Remove diret√≥rio de auth
            try {
                await fs.rmdir(tenant.authDir, { recursive: true });
            } catch (error) {
                console.error(`Erro ao remover diret√≥rio de auth para ${tenantId}:`, error);
            }
        }
    }

    getAllTenants() {
        const result = [];
        for (const [tenantId, tenant] of this.tenants) {
            result.push(tenant.getStatus());
        }
        return result;
    }
}

// Inst√¢ncia global do gerenciador de tenants
const tenantManager = new TenantManager();

// ========== APIs ========== //

// ========== APIs ========== //

/**
 * API: Enviar mensagem via empresa (compatibilidade com Flask)
 */
app.post('/send/:empresaId', async (req, res) => {
    try {
        const { empresaId } = req.params;
        const { phone, message } = req.body;

        if (!phone || !message) {
            return res.status(400).json({
                error: 'Telefone e mensagem s√£o obrigat√≥rios'
            });
        }

        // Usar empresaId como tenantId
        const tenantId = empresaId.toString();
        const tenant = await tenantManager.getTenant(tenantId);
        const result = await tenant.sendMessage(phone, message);

        res.json({
            success: true,
            empresaId: empresaId,
            ...result
        });

    } catch (error) {
        console.error(`‚ùå Erro ao enviar mensagem via empresa ${req.params.empresaId}:`, error);
        res.status(500).json({
            error: 'Erro ao enviar mensagem',
            details: error.message
        });
    }
});

/**
 * API: Webhook para enviar mensagens para o Flask
 */
app.post('/webhook', async (req, res) => {
    try {
        const data = req.body;

        if (!data || !data.phone || !data.message) {
            return res.status(400).json({
                error: 'Dados inv√°lidos'
            });
        }

        const phone = data.phone;
        const message = data.message;
        const messageType = data.message_type || 'texto';
        const mediaUrl = data.media_url;
        const mediaFilename = data.media_filename;
        const profileName = data.profile_name;
        const profilePicture = data.profile_picture;
        const empresaId = data.empresa_id || data.tenantId || 1;

        console.log(`üì® Webhook recebido de ${phone} para empresa ${empresaId}`);

        // Envia para o Flask via webhook
        try {
            await axios.post(`${FLASK_URL}/webhook/whatsapp`, {
                phone: phone,
                message: message,
                message_type: messageType,
                media_url: mediaUrl,
                media_filename: mediaFilename,
                profile_name: profileName,
                profile_picture: profilePicture,
                empresa_id: empresaId
            });
            console.log(`‚úÖ Webhook enviado para Flask: ${phone}`);
        } catch (error) {
            console.error(`‚ùå Erro ao enviar webhook para Flask: ${error.message}`);
        }

        res.json({
            success: true,
            message: 'Webhook processado com sucesso'

        });

    } catch (error) {
        console.error('‚ùå Erro no webhook:', error);
        res.status(500).json({
            error: 'Erro interno do servidor'
        });
    }
});

/**
 * API: Listar todos os tenants
 */
app.get('/tenants', (req, res) => {
    try {
        const tenants = tenantManager.getAllTenants();
        res.json({
            success: true,
            tenants: tenants
        });
    } catch (error) {
        console.error('‚ùå Erro ao listar tenants:', error);
        res.status(500).json({
            error: 'Erro ao listar tenants',
            details: error.message
        });
    }
});

/**
 * API: Criar um novo tenant
 */
app.post('/tenants', async (req, res) => {
    try {
        const { tenantId } = req.body;

        if (!tenantId) {
            return res.status(400).json({
                error: 'tenantId √© obrigat√≥rio'
            });
        }

        const tenant = await tenantManager.createTenant(tenantId);
        res.json({
            success: true,
            message: `Tenant ${tenantId} criado com sucesso`,
            tenant: tenant.getStatus()
        });
    } catch (error) {
        console.error('‚ùå Erro ao criar tenant:', error);
        res.status(500).json({
            error: 'Erro ao criar tenant',
            details: error.message
        });
    }
});

/**
 * API: Obter QR code para um tenant
 */
app.get('/tenants/:tenantId/qr', async (req, res) => {
    try {
        const { tenantId } = req.params;
        const tenant = await tenantManager.getTenant(tenantId);

        if (tenant.isConnected) {
            return res.json({
                success: true,
                connected: true,
                message: 'Tenant j√° est√° conectado'
            });
        }

        if (tenant.qrCode) {
            // Mostra QR no terminal tamb√©m
            console.log(`üì± QR Code para tenant ${tenantId}:`);
            qrcode.generate(tenant.qrCode, { small: true });

            return res.json({
                success: true,
                qrCode: tenant.qrCode,
                message: 'Escaneie o QR code com seu WhatsApp'
            });
        }

        // Se n√£o tem QR, for√ßa reconex√£o para gerar um novo
        await tenant.connect();

        // Aguarda um pouco para gerar o QR
        let attempts = 0;
        while (!tenant.qrCode && attempts < 10) {
            await new Promise(resolve => setTimeout(resolve, 1000));
            attempts++;
        }

        if (tenant.qrCode) {
            console.log(`üì± QR Code para tenant ${tenantId}:`);
            qrcode.generate(tenant.qrCode, { small: true });

            res.json({
                success: true,
                qrCode: tenant.qrCode,
                message: 'Escaneie o QR code com seu WhatsApp'
            });
        } else {
            res.status(503).json({
                success: false,
                error: 'N√£o foi poss√≠vel gerar QR code. Tente novamente.'
            });
        }
    } catch (error) {
        console.error(`‚ùå Erro ao obter QR para tenant ${req.params.tenantId}:`, error);
        res.status(500).json({
            error: 'Erro ao obter QR code',
            details: error.message
        });
    }
});

/**
 * API: Status de um tenant espec√≠fico
 */
app.get('/tenants/:tenantId/status', async (req, res) => {
    try {
        const { tenantId } = req.params;
        const tenant = await tenantManager.getTenant(tenantId);

        res.json({
            success: true,
            tenant: tenant.getStatus()
        });
    } catch (error) {
        console.error(`‚ùå Erro ao obter status do tenant ${req.params.tenantId}:`, error);
        res.status(500).json({
            error: 'Erro ao obter status do tenant',
            details: error.message
        });
    }
});

/**
 * API: Desconectar um tenant
 */
app.delete('/tenants/:tenantId', async (req, res) => {
    try {
        const { tenantId } = req.params;
        await tenantManager.deleteTenant(tenantId);

        res.json({
            success: true,
            message: `Tenant ${tenantId} desconectado e removido com sucesso`
        });
    } catch (error) {
        console.error(`‚ùå Erro ao desconectar tenant ${req.params.tenantId}:`, error);
        res.status(500).json({
            error: 'Erro ao desconectar tenant',
            details: error.message
        });
    }
});

/**
 * API: Enviar mensagem via tenant espec√≠fico
 */
app.post('/tenants/:tenantId/send', async (req, res) => {
    try {
        const { tenantId } = req.params;
        const { phone, message } = req.body;

        if (!phone || !message) {
            return res.status(400).json({
                error: 'Telefone e mensagem s√£o obrigat√≥rios'
            });
        }

        const tenant = await tenantManager.getTenant(tenantId);
        const result = await tenant.sendMessage(phone, message);

        res.json({
            success: true,
            tenantId: tenantId,
            ...result
        });

    } catch (error) {
        console.error(`‚ùå Erro ao enviar mensagem via tenant ${req.params.tenantId}:`, error);
        res.status(500).json({
            error: 'Erro ao enviar mensagem',
            details: error.message
        });
    }
});

/**
 * API: Status geral (compatibilidade com Flask)
 */
app.get('/status', (req, res) => {
    try {
        const connections = {};
        for (const [tenantId, tenant] of tenantManager.tenants) {
            connections[tenantId] = tenant.getStatus();
        }

        res.json({
            success: true,
            connections: connections,
            tenantsCount: tenantManager.tenants.size,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('‚ùå Erro ao obter status geral:', error);
        res.status(500).json({
            error: 'Erro ao obter status geral',
            details: error.message
        });
    }
});

/**
 * API: Conectar tenant (compatibilidade com Flask)
 */
app.post('/connect/:empresaId', async (req, res) => {
    try {
        const { empresaId } = req.params;
        const tenantId = empresaId.toString();

        console.log(`üìû Iniciando conex√£o para empresa ${empresaId}`);

        // Cria o tenant se n√£o existir
        const tenant = await tenantManager.getTenant(tenantId);

        // Se j√° est√° conectado, retorna sucesso
        if (tenant.isConnected) {
            return res.json({
                success: true,
                connected: true,
                message: 'Empresa j√° est√° conectada'
            });
        }

        // Inicia a conex√£o
        await tenant.connect();

        res.json({
            success: true,
            message: 'Conex√£o iniciada. Aguarde o QR code.'
        });

    } catch (error) {
        console.error(`‚ùå Erro ao conectar empresa ${req.params.empresaId}:`, error);
        res.status(500).json({
            error: 'Erro ao conectar empresa',
            details: error.message
        });
    }
});

/**
 * API: Obter QR code (compatibilidade com Flask)
 */
app.get('/qr/:empresaId', async (req, res) => {
    try {
        const { empresaId } = req.params;
        const tenantId = empresaId.toString();

        const tenant = await tenantManager.getTenant(tenantId);

        // Se j√° est√° conectado, retorna sucesso
        if (tenant.isConnected) {
            return res.json({
                success: true,
                connected: true,
                message: 'Empresa j√° est√° conectada'
            });
        }

        // Se tem QR code dispon√≠vel, retorna
        if (tenant.qrCode) {
            console.log(`üì± QR Code para empresa ${empresaId}:`);
            qrcode.generate(tenant.qrCode, { small: true });

            return res.json({
                success: true,
                qr: tenant.qrCode,
                message: 'Escaneie o QR code com seu WhatsApp'
            });
        }

        // Se n√£o tem QR, for√ßa reconex√£o para gerar um novo
        await tenant.connect();

        // Aguarda um pouco para gerar o QR (m√°ximo 15 segundos)
        let attempts = 0;
        const maxAttempts = 15;

        while (!tenant.qrCode && attempts < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 1000));
            attempts++;

            if (attempts % 5 === 0) {
                console.log(`‚è≥ Aguardando QR code para empresa ${empresaId} (${attempts}s/${maxAttempts}s)`);
            }
        }

        if (tenant.qrCode) {
            console.log(`üì± QR Code para empresa ${empresaId}:`);
            qrcode.generate(tenant.qrCode, { small: true });

            res.json({
                success: true,
                qr: tenant.qrCode,
                message: 'Escaneie o QR code com seu WhatsApp'
            });
        } else {
            console.error(`‚ùå Timeout ao gerar QR code para empresa ${empresaId}`);
            res.status(408).json({
                success: false,
                error: 'Timeout ao gerar QR code. Tente novamente.',
                timeout: true
            });
        }

    } catch (error) {
        console.error(`‚ùå Erro ao obter QR para empresa ${req.params.empresaId}:`, error);
        res.status(500).json({
            error: 'Erro ao obter QR code',
            details: error.message
        });
    }
});

/**
 * API: Desconectar empresa (compatibilidade com Flask)
 */
app.post('/disconnect/:empresaId', async (req, res) => {
    try {
        const { empresaId } = req.params;
        const tenantId = empresaId.toString();

        await tenantManager.deleteTenant(tenantId);

        res.json({
            success: true,
            message: `Empresa ${empresaId} desconectada com sucesso`
        });

    } catch (error) {
        console.error(`‚ùå Erro ao desconectar empresa ${req.params.empresaId}:`, error);
        res.status(500).json({
            error: 'Erro ao desconectar empresa',
            details: error.message
        });
    }
});

/**
 * API: Limpar todas as conex√µes (debug)
 */
app.post('/clear-all', async (req, res) => {
    try {
        console.log('üîÑ Desconectando todas as empresas...');

        for (const [tenantId, tenant] of tenantManager.tenants) {
            await tenant.disconnect();
        }

        tenantManager.tenants.clear();
        tenantManager.events.clear();

        res.json({
            success: true,
            message: 'Todas as conex√µes foram desconectadas com sucesso',
            connectionsCleared: tenantManager.tenants.size
        });

    } catch (error) {
        console.error('‚ùå Erro ao limpar conex√µes:', error);
        res.status(500).json({
            error: 'Erro ao limpar conex√µes',
            details: error.message
        });
    }
});

/**
 * API: Reinicializar empresa espec√≠fica (debug)
 */
app.post('/restart/:empresaId', async (req, res) => {
    try {
        const { empresaId } = req.params;
        const tenantId = empresaId.toString();

        console.log(`üîÑ Reinicializando empresa ${empresaId}...`);

        // Desconecta se existir
        await tenantManager.deleteTenant(tenantId);

        // Cria novamente
        const tenant = await tenantManager.getTenant(tenantId);

        res.json({
            success: true,
            message: `Empresa ${empresaId} reinicializada com sucesso`,
            tenant: tenant.getStatus()
        });

    } catch (error) {
        console.error(`‚ùå Erro ao reinicializar empresa ${req.params.empresaId}:`, error);
        res.status(500).json({
            error: 'Erro ao reinicializar empresa',
            details: error.message
        });
    }
});

/**
 * API: Health check
 */
app.get('/health', (req, res) => {
    res.json({
        status: 'ok',
        service: 'baileys-whatsapp-multitenant',
        tenantsCount: tenantManager.tenants.size,
        timestamp: new Date().toISOString()
    });
});

/**
 * Inicia o servidor
 */
app.listen(PORT, async () => {
    console.log(`üöÄ Servidor Baileys Multi-Tenant rodando na porta ${PORT}`);
    console.log(`üîó APIs Flask (compatibilidade):`);
    console.log(`   POST /send/:empresaId - Enviar mensagem via empresa (Flask)`);
    console.log(`   POST /webhook - Webhook para Flask`);
    console.log(`   GET /status - Status geral (Flask)`);
    console.log(`   POST /connect/:empresaId - Conectar empresa (Flask)`);
    console.log(`   GET /qr/:empresaId - Obter QR code (Flask)`);
    console.log(`   POST /disconnect/:empresaId - Desconectar empresa (Flask)`);
    console.log(`üîó APIs Multi-Tenant:`);
    console.log(`   GET /tenants - Listar todos os tenants`);
    console.log(`   POST /tenants - Criar novo tenant`);
    console.log(`   GET /tenants/:tenantId/qr - Obter QR code do tenant`);
    console.log(`   GET /tenants/:tenantId/status - Status do tenant`);
    console.log(`   DELETE /tenants/:tenantId - Desconectar tenant`);
    console.log(`   POST /tenants/:tenantId/send - Enviar mensagem via tenant`);
    console.log(`üîó APIs Debug:`);
    console.log(`   POST /clear-all - Limpar todas as conex√µes`);
    console.log(`   POST /restart/:empresaId - Reinicializar empresa espec√≠fica`);
    console.log(`üîó APIs Gerais:`);
    console.log(`   GET /health - Health check`);
    console.log(`üì± Sistema Multi-Tenant inicializado!`);
    console.log(`üîÑ Flask URL: ${FLASK_URL}`);

    // Cria diret√≥rio de auth se n√£o existir
    
});

// Tratamento de erros n√£o capturados
process.on('unhandledRejection', (reason, promise) => {
    console.error('‚ùå Unhandled Rejection at:', promise, 'reason:', reason);
});

process.on('uncaughtException', (error) => {
    console.error('‚ùå Uncaught Exception:', error);
    process.exit(1);
});


